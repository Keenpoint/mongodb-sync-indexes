var assert = require("assert"),
    _ = require("lodash"),
    async = require("async"),
    events = require("events");

//TODO: second style (pass db and indexes from multiple collections)

var syncIndexes = function(indexesArray, collection, options, callback) {

    // Error handling:

    // Constructor
    var syncIndexesClass = function() {
        events.EventEmitter.call(this);
    };
    require("util").inherits(syncIndexesClass, events.EventEmitter);

    // Emitter
    syncIndexesClass.prototype.emitError = function(msg) {
        var err = new Error(msg);
        this.emit("error", err);
    };

    var syncIndexesObject = new syncIndexesClass();

    // Handler
    syncIndexesObject.on("error", function(err) {
        console.log(err);
    });


    var toIgnoreInArray = ["background", "dropUps"],
        toIgnoreInDatabase = ["v", "ns"],
        toIgnoreIfUndefined = ["name"];

    var cleanIndexes = function(indexesToClean, dirty) {
        return _.map(indexesToClean, function(indexToClean) {
            return _.omit(indexToClean, dirty);
        });
    };

    var dropIndexes = function(indexesToDrop, collection, callback) {

        var tasks = [];

        _.map(indexesToDrop, function(indexToDrop) {

            tasks.push(function(_callback) {

                console.log("Dropping index " + JSON.stringify(indexToDrop.key) + "... ");

                collection.dropIndex(indexToDrop.key, function(err) {
                    if(err) {
                        console.log("Error: " + err.message);
                    }
                    else {
                        console.log("Done.");
                    }

                    _callback(err);
                });
            })
        });

        //TODO: parallel?
        async.series(
            tasks,
            function(err) {
                assert.equal(err);
                callback(err);
            }
        );
    };

    var createIndexes = function(indexesToCreate, collection, callback) {

        var tasks = [];

        _.map(indexesToCreate, function(indexToCreate) {
            tasks.push(function(_callback) {

                console.log("Creating index " + JSON.stringify(indexToCreate.key) + "... ");

                var options = getOptionsFromCleanIndex(indexToCreate);

                collection.createIndex(indexToCreate.key, options, function(err, indexName) {

                    if(err) {
                        console.log("Error: " + err.message);
                    }
                    else {
                        console.log("Done. Name is " + indexName);
                    }

                    _callback(err);
                });
            });
        });

        //TODO: parallel?
        async.series(
            tasks,
            function(err) {
                assert.equal(err);
                callback(err);
            }
        );
    };

    var isEqual = function(cleanIndexCollection, cleanIndexArray) {

        var toIgnore = _.chain(toIgnoreIfUndefined)
            .map(function(_toIgnoreIfUndefined) {
                if(cleanIndexArray[_toIgnoreIfUndefined] === undefined) return _toIgnoreIfUndefined;
            })
            .compact()
            .value();

        cleanIndexCollection = _.omit(cleanIndexCollection, toIgnore);

        return _.isEqual(cleanIndexCollection, cleanIndexArray);
    };

    var differences = function(cleanIndexesCollection, cleanIndexesArray) {

        return {
            toDrop: function() {
                return _.chain(cleanIndexesCollection)
                    .reject(function(cleanIndexCollection) {

                        var presentInArray = false;
                        _.map(cleanIndexesArray, function(cleanIndexArray) {
                            if(isEqual(cleanIndexCollection, cleanIndexArray)) presentInArray = true;
                        });

                        return presentInArray;
                    })
                    .compact()
                    .value();
            },

            toCreate: function() {
                return _.chain(cleanIndexesArray)
                    .reject(function(cleanIndexArray) {

                        var presentInCollection = false;
                        _.map(cleanIndexesCollection, function(cleanIndexCollection) {
                            if(isEqual(cleanIndexCollection, cleanIndexArray)) presentInCollection = true;
                        });

                        return presentInCollection;
                    })
                    .compact()
                    .value();
            }
        }
    };

    // Function to ignore index of key {_id: 1} (automatically generated by mongodb, not deletable).
    var ignoreMainIndex = function(indexes) {
        return _.reject(indexes, function(index) {
            //We reject if the expression below is true (the index is the main one).
            return (_.isEqual(index.key, {"_id": 1}));
        });
    };

    // Verifies existence of key in all indexes
    var allIndexesHaveAKey = function(indexesArray) {
        return _.every(indexesArray, "key");
    };

    // A priori, everything that's not the index neither an ignorable property is an option (additional information
    // to create the index).
    var getOptionsFromCleanIndex = function(index) {
        return _.omit(index, "key");
    };

    collection.indexes(function(err, indexesCollection) {
        if(err) {
            syncIndexesObject.emitError("Hello");
            return callback(err);
        }

        if(!allIndexesHaveAKey(indexesArray)) callback("Error: without key");

        var cleanIndexesCollection = ignoreMainIndex(cleanIndexes(indexesCollection, toIgnoreInDatabase)),
            cleanIndexesArray = ignoreMainIndex(cleanIndexes(indexesArray, toIgnoreInArray));

        var diff = differences(cleanIndexesCollection, cleanIndexesArray);

        var indexesToDrop = diff.toDrop(),
            indexesToCreate = diff.toCreate();

        async.series(
            [
                function(_callback) {
                    dropIndexes(indexesToDrop, collection, _callback);
                },
                function(_callback) {
                    createIndexes(indexesToCreate, collection, _callback);
                }
            ],
            function(err) {
                // Close connection even if there's an error
                db.close();
                if(err) {
                    console.log("Error: " + err.message);
                    callback(err);
                }
            }
        );

        return callback();
    });

};

module.exports = syncIndexes;
