var _ = require("lodash"),
    async = require("async"),
    events = require("events");

//TODO: second style (pass db and indexes from multiple collections)

var syncIndexes = function(indexesArray, collection, options, callback) {

    var eventHandlerClass = function() {
        events.EventEmitter.call(this);
    };
    require("util").inherits(eventHandlerClass, events.EventEmitter);

    var eventHandler = new eventHandlerClass();

    // Handlers

    eventHandler.on("error", function(err) {
        if(options !== undefined && options.log) console.log(err);
    });

    eventHandler.on("dropIndex", function(key) {
        if(options !== undefined && options.log) console.log("Dropping index " + key + "... ");
    });

    eventHandler.on("createIndex", function(key) {
        if(options !== undefined && options.log) console.log("Creating index " + key + "... ");
    });

    eventHandler.on("confirmation", function(name) {
        if(options !== undefined && options.log) console.log("Done. Name is " + name);
    });

    var toIgnoreInArray = ["background", "dropUps"],
        toIgnoreInDatabase = ["v", "ns"],
        toIgnoreIfUndefined = ["name"];

    var cleanIndexes = function(indexesToClean, dirty) {
        return _.map(indexesToClean, function(indexToClean) {
            return _.omit(indexToClean, dirty);
        });
    };

    var dropIndexes = function(indexesToDrop, collection, callback) {

        var tasks = [];

        _.map(indexesToDrop, function(indexToDrop) {

            tasks.push(function(_callback) {

                eventHandler.emit("dropIndex", JSON.stringify(indexToDrop.key));

                collection.dropIndex(indexToDrop.key, function(err) {

                    if(!err) {
                        eventHandler.emit("confirmation", indexToDrop.name);
                    }

                    _callback(err);
                });
            })
        });

        //async.series in order to get the confirmation messages right
        async.series(
            tasks,
            function(err) {
                if(err) {
                    eventHandler.emit("error", err);
                }
                callback(err);
            }
        );
    };

    var createIndexes = function(indexesToCreate, collection, callback) {

        var tasks = [];

        _.map(indexesToCreate, function(indexToCreate) {
            tasks.push(function(_callback) {

                eventHandler.emit("createIndex", JSON.stringify(indexToCreate.key));

                var options = getOptionsFromCleanIndex(indexToCreate);

                collection.createIndex(indexToCreate.key, options, function(err, indexName) {

                    if(!err) {
                        eventHandler.emit("confirmation", indexName);
                    }

                    _callback(err);
                });
            });
        });

        //async.series in order to get the confirmation messages right
        async.series(
            tasks,
            function(err) {
                if(err) {
                    eventHandler.emit("error", err);
                }
                callback(err);
            }
        );
    };

    var isEqual = function(cleanIndexCollection, cleanIndexArray) {

        var toIgnore = _.chain(toIgnoreIfUndefined)
            .map(function(_toIgnoreIfUndefined) {
                if(cleanIndexArray[_toIgnoreIfUndefined] === undefined) return _toIgnoreIfUndefined;
            })
            .compact()
            .value();

        cleanIndexCollection = _.omit(cleanIndexCollection, toIgnore);

        return _.isEqual(cleanIndexCollection, cleanIndexArray);
    };

    var differences = function(cleanIndexesCollection, cleanIndexesArray) {

        return {
            toDrop: function() {
                return _.chain(cleanIndexesCollection)
                    .reject(function(cleanIndexCollection) {

                        var presentInArray = false;
                        _.map(cleanIndexesArray, function(cleanIndexArray) {
                            if(isEqual(cleanIndexCollection, cleanIndexArray)) presentInArray = true;
                        });

                        return presentInArray;
                    })
                    .compact()
                    .value();
            },

            toCreate: function() {
                return _.chain(cleanIndexesArray)
                    .reject(function(cleanIndexArray) {

                        var presentInCollection = false;
                        _.map(cleanIndexesCollection, function(cleanIndexCollection) {
                            if(isEqual(cleanIndexCollection, cleanIndexArray)) presentInCollection = true;
                        });

                        return presentInCollection;
                    })
                    .compact()
                    .value();
            }
        }
    };

    // Function to ignore index of key {_id: 1} (automatically generated by mongodb, not deletable).
    var ignoreMainIndex = function(indexes) {
        return _.reject(indexes, function(index) {
            //We reject if the expression below is true (the index is the main one).
            return (_.isEqual(index.key, {"_id": 1}));
        });
    };

    // Verifies existence of key in all indexes
    var allIndexesHaveAKey = function(indexesArray) {
        return _.every(indexesArray, "key");
    };

    // A priori, everything that's not the index neither an ignorable property is an option (additional information
    // to create the index).
    var getOptionsFromCleanIndex = function(index) {
        return _.omit(index, "key");
    };

    // Start point of the function syncIndexesOneCollection
    collection.indexes(function(err, indexesCollection) {
        if(err) {
            eventHandler.emit("error", err);
            return callback(err);
        }

        if(!allIndexesHaveAKey(indexesArray)) {
            var _err =  new Error("Your array has at least one index without the 'key' property.");
            eventHandler.emit("error", _err);
            return callback(_err);
        }

        var cleanIndexesCollection = ignoreMainIndex(cleanIndexes(indexesCollection, toIgnoreInDatabase)),
            cleanIndexesArray = ignoreMainIndex(cleanIndexes(indexesArray, toIgnoreInArray));

        var diff = differences(cleanIndexesCollection, cleanIndexesArray);

        var indexesToDrop = diff.toDrop(),
            indexesToCreate = diff.toCreate();

        async.series(
            [
                function(_callback) {
                    dropIndexes(indexesToDrop, collection, _callback);
                },
                function(_callback) {
                    createIndexes(indexesToCreate, collection, _callback);
                }
            ],
            function(err) {
                if(err) {
                    eventHandler.emit("error", err);
                    return callback(err);
                }
                else {
                    db.close();
                }
            }
        );

        return callback();
    });

};

module.exports = syncIndexes;
